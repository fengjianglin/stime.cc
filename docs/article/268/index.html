<!DOCTYPE html>
<html lang="en-US">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="profile" href="http://gmpg.org/xfn/11">
	<title>面试官问我同步容器（如Vector）的所有操作一定是线程安全的吗？我懵了！ - S时代</title>


<meta name="robots" content="max-snippet:-1, max-image-preview:large, max-video-preview:-1">
<link rel="canonical" href="https://stime.cc/article/268/">
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="面试官问我同步容器（如Vector）的所有操作一定是线程安全的吗？我懵了！ - S时代">
<meta property="og:description" content='为了方便编写出线程安全的程序，Java里面提供了一些线程安全类和并发工具，比如：同步容器、并发容器、阻塞队列等。 最常见的同步容器就是Vector和Hashtable了，那么，同步容器的所有操作都是线程安全的吗？ 这个问题不知道你有没有想过，本文就来深入分析一下这个问题，一个很容易被忽略的问题。 1 同步容器 在Java中，同步容器主要包括2类： 1、Vector、Stack、HashTable 2、Collections类中提供的静态工厂方法创建的类 本文拿相对简单的Vecotr来举例，我们先来看下Vector中几个重要方法的源码： public synchronized boolean add(E e) {    modCount++;    ensureCapacityHelper(elementCount + 1);    elementData[elementCount++] = e;    return true;}public synchronized E remove(int index) {    modCount++;    if (index >= elementCount)        throw new ArrayIndexOutOfBoundsException(index);    E oldValue = elementData(index);    int numMoved = elementCount - index - 1;    if (numMoved > 0)        System.arraycopy(elementData, index+1, elementData, index,                         numMoved);    elementData[--elementCount] = null; // Let gc do its work    return oldValue;}public synchronized E get(int index) {    if (index >= elementCount)        throw new ArrayIndexOutOfBoundsException(index);    return elementData(index);} 可以看到，Vector这样的同步容器的所有公有方法全都是synchronized的，也就是说，我们可以在多线程场景中放心的使用单独这些方法，因为这些方法本身的确是线程安全的。 但是，请注意上面这句话中，有一个比较关键的词：单独 因为，虽然同步容器的所有方法都加了锁，但是对这些容器的复合操作无法保证其线程安全性。需要客户端通过主动加锁来保证。 简单举一个例子，我们定义如下删除Vector中最后一个元素方法： public Object deleteLast(Vector v){    int lastIndex  = v.size()-1;    v.remove(lastIndex);} 上面这个方法是一个复合方法，包括size(）和remove()，乍一看上去好像并没有什么问题，无论是size()方法还是remove()方法都是线程安全的，那么整个deleteLast方法应该也是线程安全的。 但是时，如果多线程调用该方法的过程中，remove方法有可能抛出ArrayIndexOutOfBoundsException。 Exception in thread "Thread-1" java.lang.ArrayIndexOutOfBoundsException: Array index out of range: 879    at java.util.Vector.remove(Vector.java:834)    at com.hollis.Test.deleteLast(EncodeTest.java:40)    at com.hollis.Test$2.run(EncodeTest.java:28)    at java.lang.Thread.run(Thread.java:748) 我们上面贴了remove的源码，我们可以分析得出：当index >= elementCount时，会抛出ArrayIndexOutOfBoundsException ，也就是说，当当前索引值不再有效的时候，将会抛出这个异常。 因为removeLast方法，有可能被多个线程同时执行，当线程2通过index()获得索引值为10，在尝试通过remove()删除该索引位置的元素之前，线程1把该索引位置的值删除掉了，这时线程一在执行时便会抛出异常。 为了避免出现类似问题，可以尝试加锁： public void deleteLast() {    synchronized (v) {        int index = v.size() - 1;        v.remove(index);    }} 如上，我们在deleteLast中，对v进行加锁，即可保证同一时刻，不会有其他线程删除掉v中的元素。 另外，如果以下代码会被多线程执行时，也要特别注意： for (int i = 0; i < v.size(); i++) {    v.remove(i);} 由于，不同线程在同一时间操作同一个Vector，其中包括删除操作，那么就同样有可能发生线程安全问题。所以，在使用同步容器的时候，如果涉及到多个线程同时执行删除操作，就要考虑下是否需要加锁。 2 同步容器的问题 前面说过了，同步容器直接保证单个操作的线程安全性，但是无法保证复合操作的线程安全，遇到这种情况时，必须要通过主动加锁的方式来实现。 而且，除此之外，同步容易由于对其所有方法都加了锁，这就导致多个线程访问同一个容器的时候，只能进行顺序访问，即使是不同的操作，也要排队，如get和add要排队执行。这就大大的降低了容器的并发能力。 3 并发容器 针对前文提到的同步容器存在的并发度低问题，从Java5开始，java.util.concurent包下，提供了大量支持高效并发的访问的集合类，我们称之为并发容器。 针对前文提到的同步容器的复合操作的问题，一般在Map中发生的比较多，所以在ConcurrentHashMap中增加了对常用复合操作的支持，比如putIfAbsent()、replace()，这2个操作都是原子操作，可以保证线程安全。 另外，并发包中的CopyOnWriteArrayList和CopyOnWriteArraySet是Copy-On-Write的两种实现。 Copy-On-Write容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。 CopyOnWriteArrayList中add/remove等写方法是需要加锁的，而读方法是没有加锁的。 这样做的好处是我们可以对CopyOnWrite容器进行并发的读，当然，这里读到的数据可能不是最新的。因为写时复制的思想是通过延时更新的策略来实现数据的最终一致性的，并非强一致性。 但是，作为代替Vector的CopyOnWriteArrayList并没有解决同步容器的复合操作的线程安全性问题。 4 总结 本文介绍了同步容器和并发容器。 同步容器是通过加锁实现线程安全的，并且只能保证单独的操作是线程安全的，无法保证复合操作的线程安全性。并且同步容器的读和写操作之间会互相阻塞。 并发容器是Java 5中提供的，主要用来代替同步容器。有更好的并发能力。而且其中的ConcurrentHashMap定义了线程安全的复合操作。 在多线程场景中，如果使用并发容器，一定要注意复合操作的线程安全问题。必要时候要主动加锁。 在并发场景中，建议直接使用java.util.concurent包中提供的容器类，如果需要复合操作时，建议使用有些容器自身提供的复合方法。 好文章，我在看❤️'>
<meta property="og:url" content="https://stime.cc/article/268/">
<meta property="og:site_name" content="S时代">
<meta property="article:section" content="未分类">
<meta property="article:published_time" content="2020-01-19T02:44:55+00:00">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:description" content='为了方便编写出线程安全的程序，Java里面提供了一些线程安全类和并发工具，比如：同步容器、并发容器、阻塞队列等。 最常见的同步容器就是Vector和Hashtable了，那么，同步容器的所有操作都是线程安全的吗？ 这个问题不知道你有没有想过，本文就来深入分析一下这个问题，一个很容易被忽略的问题。 1 同步容器 在Java中，同步容器主要包括2类： 1、Vector、Stack、HashTable 2、Collections类中提供的静态工厂方法创建的类 本文拿相对简单的Vecotr来举例，我们先来看下Vector中几个重要方法的源码： public synchronized boolean add(E e) {    modCount++;    ensureCapacityHelper(elementCount + 1);    elementData[elementCount++] = e;    return true;}public synchronized E remove(int index) {    modCount++;    if (index >= elementCount)        throw new ArrayIndexOutOfBoundsException(index);    E oldValue = elementData(index);    int numMoved = elementCount - index - 1;    if (numMoved > 0)        System.arraycopy(elementData, index+1, elementData, index,                         numMoved);    elementData[--elementCount] = null; // Let gc do its work    return oldValue;}public synchronized E get(int index) {    if (index >= elementCount)        throw new ArrayIndexOutOfBoundsException(index);    return elementData(index);} 可以看到，Vector这样的同步容器的所有公有方法全都是synchronized的，也就是说，我们可以在多线程场景中放心的使用单独这些方法，因为这些方法本身的确是线程安全的。 但是，请注意上面这句话中，有一个比较关键的词：单独 因为，虽然同步容器的所有方法都加了锁，但是对这些容器的复合操作无法保证其线程安全性。需要客户端通过主动加锁来保证。 简单举一个例子，我们定义如下删除Vector中最后一个元素方法： public Object deleteLast(Vector v){    int lastIndex  = v.size()-1;    v.remove(lastIndex);} 上面这个方法是一个复合方法，包括size(）和remove()，乍一看上去好像并没有什么问题，无论是size()方法还是remove()方法都是线程安全的，那么整个deleteLast方法应该也是线程安全的。 但是时，如果多线程调用该方法的过程中，remove方法有可能抛出ArrayIndexOutOfBoundsException。 Exception in thread "Thread-1" java.lang.ArrayIndexOutOfBoundsException: Array index out of range: 879    at java.util.Vector.remove(Vector.java:834)    at com.hollis.Test.deleteLast(EncodeTest.java:40)    at com.hollis.Test$2.run(EncodeTest.java:28)    at java.lang.Thread.run(Thread.java:748) 我们上面贴了remove的源码，我们可以分析得出：当index >= elementCount时，会抛出ArrayIndexOutOfBoundsException ，也就是说，当当前索引值不再有效的时候，将会抛出这个异常。 因为removeLast方法，有可能被多个线程同时执行，当线程2通过index()获得索引值为10，在尝试通过remove()删除该索引位置的元素之前，线程1把该索引位置的值删除掉了，这时线程一在执行时便会抛出异常。 为了避免出现类似问题，可以尝试加锁： public void deleteLast() {    synchronized (v) {        int index = v.size() - 1;        v.remove(index);    }} 如上，我们在deleteLast中，对v进行加锁，即可保证同一时刻，不会有其他线程删除掉v中的元素。 另外，如果以下代码会被多线程执行时，也要特别注意： for (int i = 0; i < v.size(); i++) {    v.remove(i);} 由于，不同线程在同一时间操作同一个Vector，其中包括删除操作，那么就同样有可能发生线程安全问题。所以，在使用同步容器的时候，如果涉及到多个线程同时执行删除操作，就要考虑下是否需要加锁。 2 同步容器的问题 前面说过了，同步容器直接保证单个操作的线程安全性，但是无法保证复合操作的线程安全，遇到这种情况时，必须要通过主动加锁的方式来实现。 而且，除此之外，同步容易由于对其所有方法都加了锁，这就导致多个线程访问同一个容器的时候，只能进行顺序访问，即使是不同的操作，也要排队，如get和add要排队执行。这就大大的降低了容器的并发能力。 3 并发容器 针对前文提到的同步容器存在的并发度低问题，从Java5开始，java.util.concurent包下，提供了大量支持高效并发的访问的集合类，我们称之为并发容器。 针对前文提到的同步容器的复合操作的问题，一般在Map中发生的比较多，所以在ConcurrentHashMap中增加了对常用复合操作的支持，比如putIfAbsent()、replace()，这2个操作都是原子操作，可以保证线程安全。 另外，并发包中的CopyOnWriteArrayList和CopyOnWriteArraySet是Copy-On-Write的两种实现。 Copy-On-Write容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。 CopyOnWriteArrayList中add/remove等写方法是需要加锁的，而读方法是没有加锁的。 这样做的好处是我们可以对CopyOnWrite容器进行并发的读，当然，这里读到的数据可能不是最新的。因为写时复制的思想是通过延时更新的策略来实现数据的最终一致性的，并非强一致性。 但是，作为代替Vector的CopyOnWriteArrayList并没有解决同步容器的复合操作的线程安全性问题。 4 总结 本文介绍了同步容器和并发容器。 同步容器是通过加锁实现线程安全的，并且只能保证单独的操作是线程安全的，无法保证复合操作的线程安全性。并且同步容器的读和写操作之间会互相阻塞。 并发容器是Java 5中提供的，主要用来代替同步容器。有更好的并发能力。而且其中的ConcurrentHashMap定义了线程安全的复合操作。 在多线程场景中，如果使用并发容器，一定要注意复合操作的线程安全问题。必要时候要主动加锁。 在并发场景中，建议直接使用java.util.concurent包中提供的容器类，如果需要复合操作时，建议使用有些容器自身提供的复合方法。 好文章，我在看❤️'>
<meta name="twitter:title" content="面试官问我同步容器（如Vector）的所有操作一定是线程安全的吗？我懵了！ - S时代">
<meta name="twitter:image" content="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/6fuT3emWI5LDJE14LEwQdOfQsD3BhaXRtxJ1unpgEKrcibQmrib4UUFibOZzvgicmUyVGxia3kJMQj8O3Lv4oh0nAPA/640">
<script type="application/ld+json" class="yoast-schema-graph yoast-schema-graph--main">{"@context":"https://schema.org","@graph":[{"@type":["Person","Organization"],"@id":"https://stime.cc/#/schema/person/3d7f7c032ea7508766887da0eacfa3db","name":"S\u65f6\u4ee3","image":{"@type":"ImageObject","@id":"https://stime.cc/#personlogo","url":"https://stime.cc/wp-content/uploads/2020/01/bitbug_favicon.ico","width":128,"height":128,"caption":"S\u65f6\u4ee3"},"logo":{"@id":"https://stime.cc/#personlogo"},"sameAs":[]},{"@type":"WebSite","@id":"https://stime.cc/#website","url":"https://stime.cc/","name":"S\u65f6\u4ee3","publisher":{"@id":"https://stime.cc/#/schema/person/3d7f7c032ea7508766887da0eacfa3db"},"potentialAction":{"@type":"SearchAction","target":"https://stime.cc/?s={search_term_string}","query-input":"required name=search_term_string"}},{"@type":"ImageObject","@id":"https://stime.cc/article/268/#primaryimage","url":"https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/6fuT3emWI5LDJE14LEwQdOfQsD3BhaXRtxJ1unpgEKrcibQmrib4UUFibOZzvgicmUyVGxia3kJMQj8O3Lv4oh0nAPA/640"},{"@type":"WebPage","@id":"https://stime.cc/article/268/#webpage","url":"https://stime.cc/article/268/","inLanguage":"en-US","name":"\u9762\u8bd5\u5b98\u95ee\u6211\u540c\u6b65\u5bb9\u5668\uff08\u5982Vector\uff09\u7684\u6240\u6709\u64cd\u4f5c\u4e00\u5b9a\u662f\u7ebf\u7a0b\u5b89\u5168\u7684\u5417\uff1f\u6211\u61f5\u4e86\uff01 - S\u65f6\u4ee3","isPartOf":{"@id":"https://stime.cc/#website"},"primaryImageOfPage":{"@id":"https://stime.cc/article/268/#primaryimage"},"datePublished":"2020-01-19T02:44:55+00:00","dateModified":"2020-01-19T02:44:55+00:00"},{"@type":"Article","@id":"https://stime.cc/article/268/#article","isPartOf":{"@id":"https://stime.cc/article/268/#webpage"},"author":{"@id":"https://stime.cc/#/schema/person/3d7f7c032ea7508766887da0eacfa3db"},"headline":"\u9762\u8bd5\u5b98\u95ee\u6211\u540c\u6b65\u5bb9\u5668\uff08\u5982Vector\uff09\u7684\u6240\u6709\u64cd\u4f5c\u4e00\u5b9a\u662f\u7ebf\u7a0b\u5b89\u5168\u7684\u5417\uff1f\u6211\u61f5\u4e86\uff01","datePublished":"2020-01-19T02:44:55+00:00","dateModified":"2020-01-19T02:44:55+00:00","commentCount":0,"mainEntityOfPage":{"@id":"https://stime.cc/article/268/#webpage"},"publisher":{"@id":"https://stime.cc/#/schema/person/3d7f7c032ea7508766887da0eacfa3db"},"image":{"@id":"https://stime.cc/article/268/#primaryimage"},"articleSection":"\u672a\u5206\u7c7b"}]}</script>


<link rel="dns-prefetch" href="//fonts.googleapis.com">
<link rel="dns-prefetch" href="//s.w.org">
<link rel="alternate" type="application/rss+xml" title="S时代 » Feed" href="https://stime.cc/feed/">
<link rel="alternate" type="application/rss+xml" title="S时代 » Comments Feed" href="https://stime.cc/comments/feed/">
<link rel="alternate" type="application/rss+xml" title="S时代 » 面试官问我同步容器（如Vector）的所有操作一定是线程安全的吗？我懵了！ Comments Feed" href="https://stime.cc/article/268/feed/">
<link rel="stylesheet" id="wp-block-library-css" href="https://stime.cc/wp-includes/css/dist/block-library/style.min.css" type="text/css" media="all">
<link rel="stylesheet" id="font-awesome-css" href="https://stime.cc/wp-content/themes/bloggist/css/font-awesome.min.css" type="text/css" media="all">
<link rel="stylesheet" id="bloggist-style-css" href="https://stime.cc/wp-content/themes/bloggist/style.css" type="text/css" media="all">
<link crossorigin="anonymous" rel="stylesheet" id="bloggist-google-fonts-css" href="//fonts.googleapis.com/css?family=Lato%3A300%2C400%2C700%2C900&ver=5.3.2" type="text/css" media="all">
<script type="text/javascript" src="https://stime.cc/wp-includes/js/jquery/jquery.js"></script>
<script type="text/javascript" src="https://stime.cc/wp-includes/js/jquery/jquery-migrate.min.js"></script>
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="https://stime.cc/xmlrpc.php">
<link rel="pingback" href="https://stime.cc/xmlrpc.php">
		<style type="text/css">
		body, .site, .swidgets-wrap h3, .post-data-text { background: ; }
		.site-title a, .site-description { color: ; }
		.sheader { background-color:  !important; }
		.main-navigation ul li a, .main-navigation ul li .sub-arrow, .super-menu .toggle-mobile-menu,.toggle-mobile-menu:before, .mobile-menu-active .smenu-hide { color: ; }
		#smobile-menu.show .main-navigation ul ul.children.active, #smobile-menu.show .main-navigation ul ul.sub-menu.active, #smobile-menu.show .main-navigation ul li, .smenu-hide.toggle-mobile-menu.menu-toggle, #smobile-menu.show .main-navigation ul li, .primary-menu ul li ul.children li, .primary-menu ul li ul.sub-menu li, .primary-menu .pmenu, .super-menu { border-color: ; border-bottom-color: ; }
		#secondary .widget h3, #secondary .widget h3 a, #secondary .widget h4, #secondary .widget h1, #secondary .widget h2, #secondary .widget h5, #secondary .widget h6, #secondary .widget h4 a { color: ; }
		#secondary .widget a, #secondary a, #secondary .widget li a , #secondary span.sub-arrow{ color: ; }
		#secondary, #secondary .widget, #secondary .widget p, #secondary .widget li, .widget time.rpwe-time.published { color: ; }
		#secondary .swidgets-wrap, #secondary .widget ul li, .featured-sidebar .search-field { border-color: ; }
		.site-info, .footer-column-three input.search-submit, .footer-column-three p, .footer-column-three li, .footer-column-three td, .footer-column-three th, .footer-column-three caption { color: ; }
		.footer-column-three h3, .footer-column-three h4, .footer-column-three h5, .footer-column-three h6, .footer-column-three h1, .footer-column-three h2, .footer-column-three h4, .footer-column-three h3 a { color: ; }
		.footer-column-three a, .footer-column-three li a, .footer-column-three .widget a, .footer-column-three .sub-arrow { color: ; }
		.footer-column-three h3:after { background: ; }
		.site-info, .widget ul li, .footer-column-three input.search-field, .footer-column-three input.search-submit { border-color: ; }
		.site-footer { background-color: ; }
		.content-wrapper h2.entry-title a, .content-wrapper h2.entry-title a:hover, .content-wrapper h2.entry-title a:active, .content-wrapper h2.entry-title a:focus, .archive .page-header h1, .blogposts-list h2 a, .blogposts-list h2 a:hover, .blogposts-list h2 a:active, .search-results h1.page-title { color: ; }
		.blogposts-list .post-data-text, .blogposts-list .post-data-text a, .content-wrapper .post-data-text *{ color: ; }
		.blogposts-list p { color: ; }
		.page-numbers li a, .blogposts-list .blogpost-button { background: ; }
		.page-numbers li a, .blogposts-list .blogpost-button, span.page-numbers.dots, .page-numbers.current, .page-numbers li a:hover { color: ; }
		.archive .page-header h1, .search-results h1.page-title, .blogposts-list.fbox, span.page-numbers.dots, .page-numbers li a, .page-numbers.current { border-color: ; }
		.blogposts-list .post-data-divider { background: ; }
		.page .comments-area .comment-author, .page .comments-area .comment-author a, .page .comments-area .comments-title, .page .content-area h1, .page .content-area h2, .page .content-area h3, .page .content-area h4, .page .content-area h5, .page .content-area h6, .page .content-area th, .single  .comments-area .comment-author, .single .comments-area .comment-author a, .single .comments-area .comments-title, .single .content-area h1, .single .content-area h2, .single .content-area h3, .single .content-area h4, .single .content-area h5, .single .content-area h6, .single .content-area th, .search-no-results h1, .error404 h1 { color: ; }
		.single .post-data-text, .page .post-data-text, .page .post-data-text a, .single .post-data-text a, .comments-area .comment-meta .comment-metadata a, .single .post-data-text * { color: ; }
		.page .content-area p, .page article, .page .content-area table, .page .content-area dd, .page .content-area dt, .page .content-area address, .page .content-area .entry-content, .page .content-area li, .page .content-area ol, .single .content-area p, .single article, .single .content-area table, .single .content-area dd, .single .content-area dt, .single .content-area address, .single .entry-content, .single .content-area li, .single .content-area ol, .search-no-results .page-content p { color: ; }
		.single .entry-content a, .page .entry-content a, .comment-content a, .comments-area .reply a, .logged-in-as a, .comments-area .comment-respond a { color: ; }
		.comments-area p.form-submit input { background: ; }
		.error404 .page-content p, .error404 input.search-submit, .search-no-results input.search-submit { color: ; }
		.page .comments-area, .page article.fbox, .page article tr, .page .comments-area ol.comment-list ol.children li, .page .comments-area ol.comment-list .comment, .single .comments-area, .single article.fbox, .single article tr, .comments-area ol.comment-list ol.children li, .comments-area ol.comment-list .comment, .error404 main#main, .error404 .search-form label, .search-no-results .search-form label, .error404 input.search-submit, .search-no-results input.search-submit, .error404 main#main, .search-no-results section.fbox.no-results.not-found{ border-color: ; }
		.single .post-data-divider, .page .post-data-divider { background: ; }
		.single .comments-area p.form-submit input, .page .comments-area p.form-submit input { color: ; }
		.bottom-header-wrapper { padding-top: px; }
		.bottom-header-wrapper { padding-bottom: px; }
		.bottom-header-wrapper { background: ; }
		.bottom-header-wrapper *{ color: ; }
		.header-widget a, .header-widget li a, .header-widget i.fa { color: ; }
		.header-widget, .header-widget p, .header-widget li, .header-widget .textwidget { color: ; }
		.header-widget .widget-title, .header-widget h1, .header-widget h3, .header-widget h2, .header-widget h4, .header-widget h5, .header-widget h6{ color: ; }
		.header-widget.swidgets-wrap, .header-widget ul li, .header-widget .search-field { border-color: ; }
		.bottom-header-title, .bottom-header-paragraph{ color: ; }

		#secondary .widget-title-lines:after, #secondary .widget-title-lines:before { background: ; }


		.header-widgets-wrapper .swidgets-wrap{ background: ; }
		.top-nav-wrapper, .primary-menu .pmenu, .super-menu, #smobile-menu, .primary-menu ul li ul.children, .primary-menu ul li ul.sub-menu { background-color: ; }
		#secondary .widget li, #secondary input.search-field, #secondary div#calendar_wrap, #secondary .tagcloud, #secondary .textwidget{ background: ; }
		#secondary .swidget { border-color: ; }
		.archive article.fbox, .search-results article.fbox, .blog article.fbox { background: ; }


		.comments-area, .single article.fbox, .page article.fbox { background: ; }
		</style>
		<link rel="amphtml" href="https://stime.cc/article/268/amp/"><link rel="icon" href="https://stime.cc/wp-content/uploads/2020/01/favicon.ico" sizes="32x32">
<link rel="icon" href="https://stime.cc/wp-content/uploads/2020/01/favicon.ico" sizes="192x192">
<link rel="apple-touch-icon-precomposed" href="https://stime.cc/wp-content/uploads/2020/01/favicon.ico">
<meta name="msapplication-TileImage" content="https://stime.cc/wp-content/uploads/2020/01/favicon.ico">
	
	<script>
		var _hmt = _hmt || [];
		(function() {
		  var hm = document.createElement("script");
		  hm.src = "https://hm.baidu.com/hm.js?871eb580cf6efb97266170c43d350eff";
		  var s = document.getElementsByTagName("script")[0]; 
		  s.parentNode.insertBefore(hm, s);
		})();
	</script>

</head>

<body class="post-template-default single single-post postid-268 single-format-standard masthead-fixed">
	<div id="page" class="site">

		<header id="masthead" class="sheader site-header clearfix">
			<nav id="primary-site-navigation" class="primary-menu main-navigation clearfix">

				<a href="#" id="pull" class="smenu-hide toggle-mobile-menu menu-toggle" aria-controls="secondary-menu" aria-expanded="false">Menu</a>
				<div class="top-nav-wrapper">
					<div class="content-wrap">
						<div class="logo-container"> 

													<a class="logofont" href="https://stime.cc/" rel="home">S时代</a>
									</div>
				<div class="center-main-menu">
					<div class="menu-caidan-container"><ul id="primary-menu" class="pmenu"><li id="menu-item-145" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-145"><a href="/">首页</a></li>
</ul></div>					</div>
				</div>
			</div>
		</nav>

		<div class="super-menu clearfix">
			<div class="super-menu-inner">
				<a href="#" id="pull" class="toggle-mobile-menu menu-toggle" aria-controls="secondary-menu" aria-expanded="false">

									</a><a class="logofont" href="https://stime.cc/" rel="home">S时代</a>
					
	</div>
</div>
<div id="mobile-menu-overlay"></div>
</header>


	
	

<div class="content-wrap">


	
	<div class="header-widgets-wrapper">
		
	
</div>



</div>

<div id="content" class="site-content clearfix">
	<div class="content-wrap">

	<div id="primary" class="featured-content content-area">
		<main id="main" class="site-main">

				<article id="post-268" class="posts-entry fbox post-268 post type-post status-publish format-standard hentry category-uncategorized">
	<header class="entry-header">
		<h1 class="entry-title">面试官问我同步容器（如Vector）的所有操作一定是线程安全的吗？我懵了！</h1>		<div class="entry-meta">
			<div class="blog-data-wrapper">
				<div class="post-data-divider"></div>
				<div class="post-data-positioning">
					<div class="post-data-text">
						<span class="posted-on">Posted on <a href="https://stime.cc/article/268/" rel="bookmark"><time class="entry-date published updated" datetime="2020-01-19T10:44:55+08:00">2020/1/19</time></a></span><span class="byline"> by <span class="author vcard"><a class="url fn n" href="https://stime.cc/article/author/fandyvon/">S时代</a></span></span>					</div>
				</div>
			</div>
		</div>
			</header>

	<div class="entry-content">
		<p style='margin-right: 8px;margin-left: 8px;font-family: -apple-system-font, system-ui, "Helvetica Neue", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei UI", "Microsoft YaHei", Arial, sans-serif;letter-spacing: 0.544px;white-space: normal;color: rgb(62, 62, 62);font-size: 16px;background-color: rgb(255, 255, 255);text-align: center;' data-mpa-powered-by="yiban.io"><span style="color: rgb(136, 136, 136);font-size: 10px;letter-spacing: 0.544px;caret-color: rgb(136, 136, 136);"><br></span></p>
<p style='margin-right: 8px;margin-left: 8px;font-family: -apple-system-font, system-ui, "Helvetica Neue", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei UI", "Microsoft YaHei", Arial, sans-serif;letter-spacing: 0.544px;white-space: normal;color: rgb(62, 62, 62);font-size: 16px;background-color: rgb(255, 255, 255);text-align: center;'><span style="font-size: 12px;letter-spacing: 0.5px;caret-color: rgb(51, 51, 51);"></span><span style="color: rgb(136, 136, 136);font-size: 10px;letter-spacing: 0.544px;caret-color: rgb(136, 136, 136);"><img data-ratio="0.5604166666666667" data-src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/6fuT3emWI5LDJE14LEwQdOfQsD3BhaXRtxJ1unpgEKrcibQmrib4UUFibOZzvgicmUyVGxia3kJMQj8O3Lv4oh0nAPA/640" data-w="960" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/6fuT3emWI5LDJE14LEwQdOfQsD3BhaXRtxJ1unpgEKrcibQmrib4UUFibOZzvgicmUyVGxia3kJMQj8O3Lv4oh0nAPA/640"></span></p>
<p style='margin: 5px 8px;font-family: -apple-system-font, system-ui, "Helvetica Neue", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei UI", "Microsoft YaHei", Arial, sans-serif;white-space: normal;color: rgb(62, 62, 62);font-size: 16px;background-color: rgb(255, 255, 255);caret-color: rgb(51, 51, 51);text-size-adjust: auto;letter-spacing: 0.5px;text-align: center;line-height: normal;'><span style="font-size: 13px;color: rgb(136, 136, 136);letter-spacing: 0.544px;"></span></p>
<p style="font-size: inherit;color: inherit;margin: 1.5em 8px;line-height: 1.5em;"><span style="font-size: 15px;letter-spacing: 0.5px;">为了方便编写出线程安全的程序，Java里面提供了一些线程安全类和并发工具，比如：同步容器、并发容器、阻塞队列等。</span></p>
<p style="font-size: inherit;color: inherit;margin: 1.5em 8px;line-height: 1.5em;"><span style="font-size: 15px;letter-spacing: 0.5px;">最常见的同步容器就是Vector和Hashtable了，那么，同步容器的所有操作都是线程安全的吗？</span></p>
<p style="font-size: inherit;color: inherit;margin: 1.5em 8px;line-height: 1.5em;"><span style="font-size: 15px;letter-spacing: 0.5px;">这个问题不知道你有没有想过，本文就来深入分析一下这个问题，一个很容易被忽略的问题。</span></p>
<section mpa-from-tpl="t">
<p style="margin-right: 8px;margin-left: 8px;clear: both;min-height: 1em;color: rgb(51, 51, 51);font-size: 16px;letter-spacing: 0.5px;text-align: center;line-height: 2em;"><em><span style="font-size: 28px;background-color: rgb(254, 254, 254);"><strong mpa-from-tpl="t" mpa-none-contnet="t">1</strong></span></em><br mpa-from-tpl="t"></p>
<section style="margin-top: -1.2em;margin-bottom: 0.65em;color: rgb(51, 51, 51);font-size: 16px;letter-spacing: 0.5px;text-align: center;" mpa-from-tpl="t">
<section data-width="20%" style="margin-right: auto;margin-left: auto;border-top: 1px solid rgb(33, 33, 34);border-right-color: rgb(33, 33, 34);border-bottom-color: rgb(33, 33, 34);border-left-color: rgb(33, 33, 34);width: 135.391px;" mpa-from-tpl="t"></section>
</section>
<p style="margin-right: 8px;margin-left: 8px;clear: both;min-height: 1em;color: rgb(51, 51, 51);font-size: 16px;letter-spacing: 0.5px;text-align: center;line-height: 1.5em;"><span style="color: rgb(0, 0, 0);"><strong mpa-from-tpl="t"><span style="font-size: 18px;" mpa-is-content="t">同步容器</span></strong></span></p>
</section>
<p style="font-size: inherit;color: inherit;margin: 1.5em 8px;line-height: 1.5em;"><span style="font-size: 15px;letter-spacing: 0.5px;">在Java中，同步容器主要包括2类：</span></p>
<ul style="margin-left: 8px;margin-right: 8px;" class="list-paddingleft-2">
<li>
<section style="line-height: 1.5em;"><span style="color: inherit;line-height: inherit;font-size: 15px;letter-spacing: 0.5px;">1、Vector、Stack、HashTable</span></section>
</li>
<li>
<section style="line-height: 1.5em;"><span style="color: inherit;line-height: inherit;font-size: 15px;letter-spacing: 0.5px;">2、Collections类中提供的静态工厂方法创建的类</span></section>
</li>
</ul>
<section style="font-size: inherit;color: inherit;margin: 1.5em 8px;line-height: 1.5em;"><span style="font-size: 15px;letter-spacing: 0.5px;">本文拿相对简单的Vecotr来举例，我们先来看下Vector中几个重要方法的源码：</span></section>
<pre style="font-size: inherit;color: inherit;line-height: inherit;"><section style="font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;line-height: 1.5em;overflow-y: auto;overflow-wrap: normal !important;word-break: normal !important;overflow-x: auto !important;display: -webkit-box !important;"><span style="letter-spacing: 0.5px;font-size: 13px;"><span style="letter-spacing: 0.5px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span style="letter-spacing: 0.5px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">public</span> <span style="letter-spacing: 0.5px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">synchronized</span> <span style="letter-spacing: 0.5px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">boolean</span> <span style="letter-spacing: 0.5px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">add</span><span style="letter-spacing: 0.5px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(E e)</span> </span>{</span><br><span style="letter-spacing: 0.5px;font-size: 13px;">    modCount++;</span><br><span style="letter-spacing: 0.5px;font-size: 13px;">    ensureCapacityHelper(elementCount + <span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">1</span>);</span><br><span style="letter-spacing: 0.5px;font-size: 13px;">    elementData[elementCount++] = e;</span><br><span style="letter-spacing: 0.5px;font-size: 13px;">    <span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span> <span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">true</span>;</span><br><span style="letter-spacing: 0.5px;font-size: 13px;">}</span><br><br><span style="letter-spacing: 0.5px;font-size: 13px;"><span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">public</span> <span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">synchronized</span> E <span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">remove</span><span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(<span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">int</span> index)</span> </span>{</span><br><span style="letter-spacing: 0.5px;font-size: 13px;">    modCount++;</span><br><span style="letter-spacing: 0.5px;font-size: 13px;">    <span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">if</span> (index >= elementCount)</span><br><span style="letter-spacing: 0.5px;font-size: 13px;">        <span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">throw</span> <span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span style="letter-spacing: 0.5px;font-size: 13px;">    E oldValue = elementData(index);</span><br><br><span style="letter-spacing: 0.5px;font-size: 13px;">    <span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">int</span> numMoved = elementCount - index - <span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">1</span>;</span><br><span style="letter-spacing: 0.5px;font-size: 13px;">    <span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">if</span> (numMoved > <span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0</span>)</span><br><span style="letter-spacing: 0.5px;font-size: 13px;">        System.arraycopy(elementData, index+<span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">1</span>, elementData, index,</span><br><span style="letter-spacing: 0.5px;font-size: 13px;">                         numMoved);</span><br><span style="letter-spacing: 0.5px;font-size: 13px;">    elementData[--elementCount] = <span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">null</span>; <span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">// Let gc do its work</span></span><span style="line-height: inherit;color: rgb(128, 128, 128);letter-spacing: 0.5px;font-size: 13px;overflow-wrap: inherit !important;word-break: inherit !important;"></span><br><br><span style="letter-spacing: 0.5px;font-size: 13px;">    <span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span> oldValue;</span><br><span style="letter-spacing: 0.5px;font-size: 13px;">}</span><br><br><span style="letter-spacing: 0.5px;font-size: 13px;"><span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">public</span> <span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">synchronized</span> E <span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">get</span><span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(<span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">int</span> index)</span> </span>{</span><br><span style="letter-spacing: 0.5px;font-size: 13px;">    <span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">if</span> (index >= elementCount)</span><br><span style="letter-spacing: 0.5px;font-size: 13px;">        <span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">throw</span> <span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">new</span> ArrayIndexOutOfBoundsException(index);</span><br><br><span style="letter-spacing: 0.5px;font-size: 13px;">    <span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span> elementData(index);</span><br><span style="letter-spacing: 0.5px;font-size: 13px;">}</span><span style="font-size: 15px;letter-spacing: 0.5px;"></span><br></section></pre>
<section style="font-size: inherit;color: inherit;margin: 1.5em 8px;line-height: 1.5em;"><span style="font-size: 15px;letter-spacing: 0.5px;">可以看到，Vector这样的同步容器的所有公有方法全都是synchronized的，也就是说，我们可以在多线程场景中放心的使用单独这些方法，因为这些方法本身的确是线程安全的。</span></section>
<section style="font-size: inherit;color: inherit;margin: 1.5em 8px;line-height: 1.5em;"><span style="font-size: 15px;letter-spacing: 0.5px;">但是，请注意上面这句话中，有一个比较关键的词：单独</span></section>
<section style="font-size: inherit;color: inherit;margin: 1.5em 8px;line-height: 1.5em;"><span style='color: rgb(255, 104, 39);font-family: -apple-system-font, system-ui, "Helvetica Neue", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei UI", "Microsoft YaHei", Arial, sans-serif;font-size: 15px;letter-spacing: 0.5px;text-align: center;word-spacing: 2px;background-color: rgb(255, 255, 255);'>因为，虽然同步容器的所有方法都加了锁，但是对这些容器的复合操作无法保证其线程安全性。需要客户端通过主动加锁来保证。</span><span style='color: rgb(255, 104, 39);font-family: -apple-system-font, system-ui, "Helvetica Neue", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei UI", "Microsoft YaHei", Arial, sans-serif;font-size: 15px;letter-spacing: 0.5px;text-align: center;word-spacing: 2px;background-color: rgb(255, 255, 255);'></span></section>
<section style="font-size: inherit;color: inherit;margin: 1.5em 8px;line-height: 1.5em;"><span style="font-size: 15px;letter-spacing: 0.5px;">简单举一个例子，我们定义如下删除Vector中最后一个元素方法：</span></section>
<pre style="font-size: inherit;color: inherit;line-height: inherit;"><section style="font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;line-height: 1.5em;overflow-y: auto;overflow-wrap: normal !important;word-break: normal !important;overflow-x: auto !important;display: -webkit-box !important;"><span style="letter-spacing: 0.5px;font-size: 13px;"><span style="letter-spacing: 0.5px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span style="letter-spacing: 0.5px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">public</span> Object <span style="letter-spacing: 0.5px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">deleteLast</span>(<span style="letter-spacing: 0.5px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">Vector v</span>)</span>{</span><br><span style="letter-spacing: 0.5px;font-size: 13px;">    <span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">int</span> lastIndex  = v.size()<span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">-1</span>;</span><br><span style="letter-spacing: 0.5px;font-size: 13px;">    v.<span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">remove</span>(lastIndex);</span><br><span style="letter-spacing: 0.5px;font-size: 13px;">}</span><span style="font-size: 15px;letter-spacing: 0.5px;"></span><br></section></pre>
<section style="font-size: inherit;color: inherit;margin: 1.5em 8px;line-height: 1.5em;"><span style="font-size: 15px;letter-spacing: 0.5px;">上面这个方法是一个复合方法，包括size(）和remove()，乍一看上去好像并没有什么问题，无论是size()方法还是remove()方法都是线程安全的，那么整个deleteLast方法应该也是线程安全的。</span></section>
<section style="font-size: inherit;color: inherit;margin: 1.5em 8px;line-height: 1.5em;"><span style="font-size: 15px;letter-spacing: 0.5px;">但是时，如果多线程调用该方法的过程中，remove方法有可能抛出ArrayIndexOutOfBoundsException。</span></section>
<pre style="font-size: inherit;color: inherit;line-height: inherit;"><section style="font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;line-height: 1.5em;overflow-y: auto;overflow-wrap: normal !important;word-break: normal !important;overflow-x: auto !important;display: -webkit-box !important;"><span style="letter-spacing: 0.5px;font-size: 13px;">Exception <span style="letter-spacing: 0.5px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">in</span> thread <span style="letter-spacing: 0.5px;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"Thread-1"</span> java.lang.ArrayIndexOutOfBoundsException: Array index <span style="letter-spacing: 0.5px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">out</span> of range: <span style="letter-spacing: 0.5px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">879</span></span><span style="line-height: inherit;color: rgb(174, 135, 250);letter-spacing: 0.5px;font-size: 13px;overflow-wrap: inherit !important;word-break: inherit !important;"></span><br><span style="letter-spacing: 0.5px;font-size: 13px;">    at java.util.Vector.<span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">remove</span>(Vector.java:<span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">834</span>)</span><br><span style="letter-spacing: 0.5px;font-size: 13px;">    at com.hollis.Test.deleteLast(EncodeTest.java:<span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">40</span>)</span><br><span style="letter-spacing: 0.5px;font-size: 13px;">    at com.hollis.Test$<span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">2.</span>run(EncodeTest.java:<span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">28</span>)</span><br><span style="letter-spacing: 0.5px;font-size: 13px;">    at java.lang.Thread.run(Thread.java:<span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">748</span>)</span><span style="font-size: 15px;letter-spacing: 0.5px;"></span><br></section></pre>
<section style="font-size: inherit;color: inherit;margin: 1.5em 8px;line-height: 1.5em;"><span style="font-size: 15px;letter-spacing: 0.5px;">我们上面贴了remove的源码，我们可以分析得出：当index >= elementCount时，会抛出ArrayIndexOutOfBoundsException ，也就是说，当当前索引值不再有效的时候，将会抛出这个异常。</span></section>
<section style="font-size: inherit;color: inherit;margin: 1.5em 8px;line-height: 1.5em;"><span style="font-size: 15px;letter-spacing: 0.5px;">因为removeLast方法，有可能被多个线程同时执行，当线程2通过index()获得索引值为10，在尝试通过remove()删除该索引位置的元素之前，线程1把该索引位置的值删除掉了，这时线程一在执行时便会抛出异常。</span></section>
<figure style="font-size: inherit;color: inherit;line-height: inherit;"><img data-ratio="0.25508819538670285" data-src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/6fuT3emWI5LDJE14LEwQdOfQsD3BhaXRIBInh9PV8pfQB98NeibzsHOEuEibMiah1CTseTd5EcaaBRocAxGISbO2Q/640?wx_fmt=jpeg" data-type="jpeg" data-w="737" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;" title src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/6fuT3emWI5LDJE14LEwQdOfQsD3BhaXRIBInh9PV8pfQB98NeibzsHOEuEibMiah1CTseTd5EcaaBRocAxGISbO2Q/640?wx_fmt=jpeg"></figure>
<section style="font-size: inherit;color: inherit;margin: 1.5em 8px;line-height: 1.5em;"><span style="font-size: 15px;letter-spacing: 0.5px;">为了避免出现类似问题，可以尝试加锁：</span></section>
<pre style="font-size: inherit;color: inherit;line-height: inherit;"><section style="font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;line-height: 1.5em;overflow-y: auto;overflow-wrap: normal !important;word-break: normal !important;overflow-x: auto !important;display: -webkit-box !important;"><span style="letter-spacing: 0.5px;font-size: 13px;"><span style="letter-spacing: 0.5px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span style="letter-spacing: 0.5px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">public</span> <span style="letter-spacing: 0.5px;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">void</span> <span style="letter-spacing: 0.5px;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">deleteLast</span>(<span style="letter-spacing: 0.5px;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;"></span>) </span>{</span><br><span style="letter-spacing: 0.5px;font-size: 13px;">    synchronized (v) {</span><br><span style="letter-spacing: 0.5px;font-size: 13px;">        <span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">int</span> index = v.size() - <span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">1</span>;</span><br><span style="letter-spacing: 0.5px;font-size: 13px;">        v.<span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">remove</span>(index);</span><br><span style="letter-spacing: 0.5px;font-size: 13px;">    }</span><br><span style="letter-spacing: 0.5px;font-size: 13px;">}</span><span style="font-size: 15px;letter-spacing: 0.5px;"></span><br></section></pre>
<section style="font-size: inherit;color: inherit;margin: 1.5em 8px;line-height: 1.5em;"><span style="font-size: 15px;letter-spacing: 0.5px;">如上，我们在deleteLast中，对v进行加锁，即可保证同一时刻，不会有其他线程删除掉v中的元素。</span></section>
<section style="font-size: inherit;color: inherit;margin: 1.5em 8px;line-height: 1.5em;"><span style="font-size: 15px;letter-spacing: 0.5px;">另外，如果以下代码会被多线程执行时，也要特别注意：</span></section>
<pre style="font-size: inherit;color: inherit;line-height: inherit;"><section style="font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;line-height: 1.5em;overflow-y: auto;overflow-wrap: normal !important;word-break: normal !important;overflow-x: auto !important;display: -webkit-box !important;"><span style="letter-spacing: 0.5px;font-size: 13px;"><span style="letter-spacing: 0.5px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">for</span> (<span style="letter-spacing: 0.5px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">int</span> i = <span style="letter-spacing: 0.5px;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0</span>; i < v.size(); i++) {</span><br><span style="letter-spacing: 0.5px;font-size: 13px;">    v.<span style="font-size: 13px;letter-spacing: 0.5px;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">remove</span>(i);</span><br><span style="letter-spacing: 0.5px;font-size: 13px;">}</span><span style="font-size: 15px;letter-spacing: 0.5px;"></span><br></section></pre>
<section style="font-size: inherit;color: inherit;margin: 1.5em 8px;line-height: 1.5em;"><span style="font-size: 15px;letter-spacing: 0.5px;">由于，不同线程在同一时间操作同一个Vector，其中包括删除操作，那么就同样有可能发生线程安全问题。</span><span style='color: rgb(255, 104, 39);font-family: -apple-system-font, system-ui, "Helvetica Neue", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei UI", "Microsoft YaHei", Arial, sans-serif;font-size: 15px;letter-spacing: 0.5px;text-align: center;word-spacing: 2px;background-color: rgb(255, 255, 255);'>所以，在使用同步容器的时候，如果涉及到多个线程同时执行删除操作，就要考虑下是否需要加锁。</span></section>
<section mpa-from-tpl="t">
<p style="margin-right: 8px;margin-left: 8px;clear: both;min-height: 1em;color: rgb(51, 51, 51);font-size: 16px;letter-spacing: 0.5px;text-align: center;line-height: 2em;"><em><span style="font-size: 28px;background-color: rgb(254, 254, 254);"><strong mpa-from-tpl="t" mpa-none-contnet="t">2</strong></span></em><br mpa-from-tpl="t"></p>
<section style="margin-top: -1.2em;margin-bottom: 0.65em;color: rgb(51, 51, 51);font-size: 16px;letter-spacing: 0.5px;text-align: center;" mpa-from-tpl="t">
<section data-width="20%" style="margin-right: auto;margin-left: auto;border-top: 1px solid rgb(33, 33, 34);border-right-color: rgb(33, 33, 34);border-bottom-color: rgb(33, 33, 34);border-left-color: rgb(33, 33, 34);width: 135.391px;" mpa-from-tpl="t"></section>
</section>
<p style="margin-right: 8px;margin-left: 8px;clear: both;min-height: 1em;color: rgb(51, 51, 51);font-size: 16px;letter-spacing: 0.5px;text-align: center;line-height: 1.5em;"><span style="color: rgb(0, 0, 0);"><strong mpa-from-tpl="t"><span style="font-size: 18px;" mpa-is-content="t">同步容器的问题</span></strong></span></p>
</section>
<section style="font-size: inherit;color: inherit;margin: 1.5em 8px;line-height: 1.5em;"><span style="font-size: 15px;letter-spacing: 0.5px;">前面说过了，同步容器直接保证单个操作的线程安全性，但是无法保证复合操作的线程安全，遇到这种情况时，必须要通过主动加锁的方式来实现。</span></section>
<section style="font-size: inherit;color: inherit;margin: 1.5em 8px;line-height: 1.5em;"><span style="font-size: 15px;letter-spacing: 0.5px;">而且，除此之外，</span><span style='color: rgb(255, 104, 39);font-family: -apple-system-font, system-ui, "Helvetica Neue", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei UI", "Microsoft YaHei", Arial, sans-serif;font-size: 15px;letter-spacing: 0.5px;text-align: center;word-spacing: 2px;background-color: rgb(255, 255, 255);'>同步容易由于对其所有方法都加了锁，这就导致多个线程访问同一个容器的时候，只能进行顺序访问，即使是不同的操作，也要排队</span><span style="font-size: 15px;letter-spacing: 0.5px;">，如get和add要排队执行。这就大大的降低了容器的并发能力。</span></section>
<section mpa-from-tpl="t">
<p style="margin-right: 8px;margin-left: 8px;clear: both;min-height: 1em;color: rgb(51, 51, 51);font-size: 16px;letter-spacing: 0.5px;text-align: center;line-height: 2em;"><em><span style="font-size: 28px;background-color: rgb(254, 254, 254);"><strong mpa-from-tpl="t" mpa-none-contnet="t">3</strong></span></em><br mpa-from-tpl="t"></p>
<section style="margin-top: -1.2em;margin-bottom: 0.65em;color: rgb(51, 51, 51);font-size: 16px;letter-spacing: 0.5px;text-align: center;" mpa-from-tpl="t">
<section data-width="20%" style="margin-right: auto;margin-left: auto;border-top: 1px solid rgb(33, 33, 34);border-right-color: rgb(33, 33, 34);border-bottom-color: rgb(33, 33, 34);border-left-color: rgb(33, 33, 34);width: 135.391px;" mpa-from-tpl="t"></section>
</section>
<p style="margin-right: 8px;margin-left: 8px;clear: both;min-height: 1em;color: rgb(51, 51, 51);font-size: 16px;letter-spacing: 0.5px;text-align: center;line-height: 1.5em;"><span style="color: rgb(0, 0, 0);"><strong mpa-from-tpl="t"><span style="font-size: 18px;" mpa-is-content="t">并发容器</span></strong></span></p>
</section>
<section style="font-size: inherit;color: inherit;margin: 1.5em 8px;line-height: 1.5em;"><span style="font-size: 15px;letter-spacing: 0.5px;">针对前文提到的同步容器存在的并发度低问题，从Java5开始，java.util.concurent包下，提供了大量支持高效并发的访问的集合类，我们称之为并发容器。</span></section>
<figure style="font-size: inherit;color: inherit;line-height: inherit;"><img data-ratio="0.9134615384615384" data-src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/6fuT3emWI5LDJE14LEwQdOfQsD3BhaXRafShHplrGpwuepicPSibLTuFrjAchFjhyq0kicGbdYYxFNk1ibg7fBibD0g/640?wx_fmt=jpeg" data-type="jpeg" data-w="208" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;" title src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/6fuT3emWI5LDJE14LEwQdOfQsD3BhaXRafShHplrGpwuepicPSibLTuFrjAchFjhyq0kicGbdYYxFNk1ibg7fBibD0g/640?wx_fmt=jpeg"></figure>
<section style="font-size: inherit;color: inherit;margin: 1.5em 8px;line-height: 1.5em;"><span style="font-size: 15px;letter-spacing: 0.5px;">针对前文提到的同步容器的复合操作的问题，一般在Map中发生的比较多，所以在ConcurrentHashMap中增加了对常用复合操作的支持，比如putIfAbsent()、replace()，这2个操作都是原子操作，可以保证线程安全。</span></section>
<section style="font-size: inherit;color: inherit;margin: 1.5em 8px;line-height: 1.5em;"><span style="font-size: 15px;letter-spacing: 0.5px;">另外，并发包中的CopyOnWriteArrayList和CopyOnWriteArraySet是Copy-On-Write的两种实现。</span></section>
<section style="font-size: inherit;color: inherit;margin: 1.5em 8px;line-height: 1.5em;"><span style="font-size: 15px;letter-spacing: 0.5px;">Copy-On-Write容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。</span></section>
<section style="font-size: inherit;color: inherit;margin: 1.5em 8px;line-height: 1.5em;"><span style='color: rgb(255, 104, 39);font-family: -apple-system-font, system-ui, "Helvetica Neue", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei UI", "Microsoft YaHei", Arial, sans-serif;font-size: 15px;letter-spacing: 0.5px;text-align: center;word-spacing: 2px;background-color: rgb(255, 255, 255);'>CopyOnWriteArrayList中add/remove等写方法是需要加锁的，而读方法是没有加锁的。</span><span style="font-size: 15px;letter-spacing: 0.5px;"></span></section>
<section style="font-size: inherit;color: inherit;margin: 1.5em 8px;line-height: 1.5em;"><span style="font-size: 15px;letter-spacing: 0.5px;">这样做的好处是我们可以对CopyOnWrite容器进行并发的读，当然，这里读到的数据可能不是最新的。因为写时复制的思想是通过延时更新的策略来实现数据的最终一致性的，并非强一致性。</span></section>
<section style="font-size: inherit;color: inherit;margin: 1.5em 8px;line-height: 1.5em;"><span style="font-size: 15px;letter-spacing: 0.5px;">但是，作为代替Vector的CopyOnWriteArrayList并没有解决同步容器的复合操作的线程安全性问题。</span></section>
<section mpa-from-tpl="t">
<p style="margin-right: 8px;margin-left: 8px;clear: both;min-height: 1em;color: rgb(51, 51, 51);font-size: 16px;letter-spacing: 0.5px;text-align: center;line-height: 2em;"><em><span style="font-size: 28px;background-color: rgb(254, 254, 254);"><strong mpa-from-tpl="t" mpa-none-contnet="t">4</strong></span></em><br mpa-from-tpl="t"></p>
<section style="margin-top: -1.2em;margin-bottom: 0.65em;color: rgb(51, 51, 51);font-size: 16px;letter-spacing: 0.5px;text-align: center;" mpa-from-tpl="t">
<section data-width="20%" style="margin-right: auto;margin-left: auto;border-top: 1px solid rgb(33, 33, 34);border-right-color: rgb(33, 33, 34);border-bottom-color: rgb(33, 33, 34);border-left-color: rgb(33, 33, 34);width: 135.391px;" mpa-from-tpl="t"></section>
</section>
<p style="margin-right: 8px;margin-left: 8px;clear: both;min-height: 1em;color: rgb(51, 51, 51);font-size: 16px;letter-spacing: 0.5px;text-align: center;line-height: 1.5em;"><span style="color: rgb(0, 0, 0);"><strong mpa-from-tpl="t"><span style="font-size: 18px;" mpa-is-content="t">总结</span></strong></span></p>
</section>
<section style="font-size: inherit;color: inherit;margin: 1.5em 8px;line-height: 1.5em;"><span style="font-size: 15px;letter-spacing: 0.5px;">本文介绍了同步容器和并发容器。</span></section>
<section style="font-size: inherit;color: inherit;margin: 1.5em 8px;line-height: 1.5em;"><span style="font-size: 15px;letter-spacing: 0.5px;">同步容器是通过加锁实现线程安全的，并且只能保证单独的操作是线程安全的，无法保证复合操作的线程安全性。并且同步容器的读和写操作之间会互相阻塞。</span></section>
<section style="font-size: inherit;color: inherit;margin: 1.5em 8px;line-height: 1.5em;"><span style="font-size: 15px;letter-spacing: 0.5px;">并发容器是Java 5中提供的，主要用来代替同步容器。有更好的并发能力。而且其中的ConcurrentHashMap定义了线程安全的复合操作。</span></section>
<section style="font-size: inherit;color: inherit;margin: 1.5em 8px;line-height: 1.5em;"><span style="font-size: 15px;letter-spacing: 0.5px;">在多线程场景中，如果使用并发容器，一定要注意复合操作的线程安全问题。必要时候要主动加锁。</span></section>
<section style="font-size: inherit;color: inherit;margin: 1.5em 8px;line-height: 1.5em;"><span style="font-size: 15px;letter-spacing: 0.5px;">在并发场景中，建议直接使用java.util.concurent包中提供的容器类，如果需要复合操作时，建议使用有些容器自身提供的复合方法。</span></section>
<p style="text-align: center;"><img class="rich_pages" data-ratio="0.5555555555555556" data-s="300,640" data-src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/uChmeeX1Fpy76wXSVxMiaQMMAWdDrcZW2of9SKBg0XHDWwG7kV34aQr4oer9fuZhaqNE6uDGGrlEFpET4aXbIrQ/640?wx_fmt=png" data-type="png" data-w="900" style src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/uChmeeX1Fpy76wXSVxMiaQMMAWdDrcZW2of9SKBg0XHDWwG7kV34aQr4oer9fuZhaqNE6uDGGrlEFpET4aXbIrQ/640?wx_fmt=png"></p>
<section style='font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: "Helvetica Neue", Helvetica, "Hiragino Sans GB", "Microsoft YaHei", Arial, sans-serif;'>
<section mpa-from-tpl="t">
<section mpa-from-tpl="t" style="line-height: 1.6;letter-spacing: 0px;">
<section data-mpa-template-id="1025112" data-mpa-color="null" data-mpa-category="fav" mpa-from-tpl="t" style="margin-right: 0.5em;margin-left: 0.5em;letter-spacing: 0.544px;word-spacing: 2px;">
<section powered-by="xiumi.us" mpa-from-tpl="t" style="letter-spacing: 3px;text-align: center;">
<p><span style="color: rgb(160, 160, 160);font-size: 14px;letter-spacing: 2px;"></span></p>
</section>
</section>
</section>
</section>
<p style="margin: 5px 8px;font-size: inherit;color: inherit;line-height: 1.5em;text-align: right;"><span style="font-size: 14px;letter-spacing: 2px;word-spacing: 2px;color: rgb(0, 0, 0);">好文章，我</span><span style="color: rgb(160, 160, 160);font-size: 14px;letter-spacing: 2px;word-spacing: 2px;"><span style="color: rgb(255, 41, 65);">在看</span>❤️</span></p>
</section>

			</div>
</article>

<div id="comments" class="fbox comments-area">

		<div id="respond" class="comment-respond">
		<h3 id="reply-title" class="comment-reply-title">Leave a Reply <small><a rel="nofollow" id="cancel-comment-reply-link" href="/article/268/#respond" style="display:none;">Cancel reply</a></small></h3><form action="https://stime.cc/wp-comments-post.php" method="post" id="commentform" class="comment-form" novalidate><p class="comment-notes"><span id="email-notes">Your email address will not be published.</span> Required fields are marked <span class="required">*</span></p><p class="comment-form-comment"><label for="comment">Comment</label> <textarea id="comment" name="comment" cols="45" rows="8" maxlength="65525" required="required"></textarea></p><p class="comment-form-author"><label for="author">Name <span class="required">*</span></label> <input id="author" name="author" type="text" value="" size="30" maxlength="245" required="required"></p>
<p class="comment-form-email"><label for="email">Email <span class="required">*</span></label> <input id="email" name="email" type="email" value="" size="30" maxlength="100" aria-describedby="email-notes" required="required"></p>
<p class="comment-form-url"><label for="url">Website</label> <input id="url" name="url" type="url" value="" size="30" maxlength="200"></p>
<p class="comment-form-cookies-consent"><input id="wp-comment-cookies-consent" name="wp-comment-cookies-consent" type="checkbox" value="yes"> <label for="wp-comment-cookies-consent">Save my name, email, and website in this browser for the next time I comment.</label></p>
<p class="form-submit"><input name="submit" type="submit" id="submit" class="submit" value="Post Comment"> <input type="hidden" name="comment_post_ID" value="268" id="comment_post_ID">
<input type="hidden" name="comment_parent" id="comment_parent" value="0">
</p></form>	</div>
	
</div>

		</main>
	</div>


<aside id="secondary" class="featured-sidebar widget-area">
	<section id="search-7" class="fbox swidgets-wrap widget widget_search"><form role="search" target="_blank" method="get" class="search-form" action="https://google.com/search">
				<label>
					<span class="screen-reader-text">Search for:</span>
					<input type="search" class="search-field" placeholder="Search …" value="" name="q">
					<input type="hidden" name="sitesearch" value="stime.cc" style="display: block;">
				</label>
				<input type="submit" class="search-submit" value="Search">
			</form></section>		<section id="recent-posts-4" class="fbox swidgets-wrap widget widget_recent_entries">		<div class="sidebar-headline-wrapper"><div class="sidebarlines-wrapper"><div class="widget-title-lines"></div></div><h4 class="widget-title">Recent Posts</h4></div>		<ul>
											<li>
					<a href="https://stime.cc/article/364/">太突然了！篮球巨星科比去世</a>
											<span class="post-date">2020/1/27</span>
									</li>
											<li>
					<a href="https://stime.cc/article/363/">突发! 篮球巨星科比去世! 单场81分传奇让四点的洛杉矶从此黯淡</a>
											<span class="post-date">2020/1/27</span>
									</li>
											<li>
					<a href="https://stime.cc/article/362/">科比坠机去世，NBA传奇猝然谢幕！</a>
											<span class="post-date">2020/1/27</span>
									</li>
											<li>
					<a href="https://stime.cc/article/361/">突发！篮球巨星科比，刚刚去世！</a>
											<span class="post-date">2020/1/27</span>
									</li>
											<li>
					<a href="https://stime.cc/article/360/">篮球巨星科比及13岁女儿坠机去世！</a>
											<span class="post-date">2020/1/27</span>
									</li>
											<li>
					<a href="https://stime.cc/article/359/">突发！NBA球星科比去世</a>
											<span class="post-date">2020/1/27</span>
									</li>
											<li>
					<a href="https://stime.cc/article/358/">突发！篮球巨星科比，去世！</a>
											<span class="post-date">2020/1/27</span>
									</li>
											<li>
					<a href="https://stime.cc/article/357/">41岁科比去世，世间再无黑曼巴</a>
											<span class="post-date">2020/1/27</span>
									</li>
											<li>
					<a href="https://stime.cc/article/356/">科比去世了！一生无法接受的噩耗！</a>
											<span class="post-date">2020/1/27</span>
									</li>
											<li>
					<a href="https://stime.cc/article/355/">突发！科比坠机去世！</a>
											<span class="post-date">2020/1/27</span>
									</li>
					</ul>
		</section><section id="archives-4" class="fbox swidgets-wrap widget widget_archive"><div class="sidebar-headline-wrapper"><div class="sidebarlines-wrapper"><div class="widget-title-lines"></div></div><h4 class="widget-title">Archives</h4></div>		<ul>
				<li><a href="https://stime.cc/article/date/2020/01/">January 2020</a> (208)</li>
		</ul>
			</section></aside>
</div>
</div>

<footer id="colophon" class="site-footer clearfix">

	<div class="content-wrap">
		
			
			
		</div>

		<div class="site-info">
			Copyright ©2020 | S时代		</div>
	</footer></div>






<div id="smobile-menu" class="mobile-only"></div>
<div id="mobile-menu-overlay"></div>

<script type="text/javascript" src="https://stime.cc/wp-content/themes/bloggist/js/navigation.js"></script>
<script type="text/javascript" src="https://stime.cc/wp-content/themes/bloggist/js/skip-link-focus-fix.js"></script>
<script type="text/javascript" src="https://stime.cc/wp-content/themes/bloggist/js/jquery.flexslider.js"></script>
<script type="text/javascript" src="https://stime.cc/wp-content/themes/bloggist/js/script.js"></script>
</body>
</html>
